---
title: "Case_Study_Group_50"
author: "Long Dinh, Andre D체ding, Brian Eiffert, Jonas Rieger, Vanessa Schweitzer"
date: "SoSe 2020, 14/08/2020"
output: 
  html_document:
    theme: paper
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The intention of this project is to find vehicles of "Type11" and "Type12" which have installed the faulty diesel engine "K1DI1". The defective engines were produced from 1 March 2008 to 11 May 2012.  The recall action will start in the Hamburg area, as the first diesel bans come into force there. 

# Packages
Install required packages.

```{r packages, warning = FALSE,message= FALSE}
if(!require("install.load")){
  install.packages("install.load")
}
library(install.load)

install_load("readr", "tidyverse", "stringr", "readxl","ggplot2", "plotly","lubridate", "data.table","tm","geosphere","sp","knitr")
```

# Data Import

## Choice of relevant data

The required data is divided up into vehicle data, where the diesel engine data and production period is located, and geographical data consisting of the location of the cities and where the vehicles are registered. The following table gives an overview.

Vehicle data  | Geographical Data
------------- | -------------
Bestandteile_Fahrzeuge_OEM1_Typ11  | OpenGeoDB_bundesland_plz_ort_de (1)
Bestandteile_Fahrzeuge_OEM1_Typ12  | Zulassungen_alle_Fahrzeuge
Fahrzeuge_OEM1_Typ11  | Geodaten_Gemeinden_v1.2_2017-08-22_TrR
Fahrzeuge_OEM1_Typ12  |
Komponente_K1DI1      |

The task is to find all relevant type 11 and type 12 vehicles with an engine "K1DI1" produced during the problematic period from the data tables OEM1. To get the required data for vehicles, the following files are imported by the "readr" package:
"Bestandteile_Fahrzeuge_OEM1_Typ11","Bestandteile_Fahrzeuge_OEM1_Typ12" and "Komponente_K1DI1". Here, it is important to define the column types.
The data tables "Bestandteile_Fahrzeuge_OEM1_Typ11", "Bestandteile_Fahrzeuge_OEM1_Typ12" contain the relevant "ID_Motor", which is needed to match the affected engines. The data table "Komponente_K1DI1" shows the production date of the engine which is needed to find the engines that were produced during the specified period.
For easier handling of the data, redundant/unnecessary columns were detected and deleted after the import. 
```{r import vehicles, warning = FALSE, message= FALSE}
# Import Bestabdteile OEM Typ 11/12
data_bestandteile_oem1_typ11 <- read_csv2("./Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM1_Typ11.csv", col_types = cols(X1=col_integer(),ID_Karosserie=col_character(),ID_Schaltung=col_character(),ID_Sitze=col_character(),ID_Motor=col_character(),ID_Fahrzeug=col_character())) # Import data

data_bestandteile_oem1_typ12 <- read_csv2("./Data/Fahrzeug/Bestandteile_Fahrzeuge_OEM1_Typ12.csv", col_types = cols(X1=col_integer(),ID_Karosserie=col_character(),ID_Schaltung=col_character(),ID_Sitze=col_character(),ID_Motor=col_character(),ID_Fahrzeug=col_character())) # Import data


# Import Komponente K1DI1
data_komponente_k1di1 <- read_csv("./Data/Komponente/Komponente_K1DI1.csv",
col_types = cols(ID_Motor.y=col_character(),
                 Produktionsdatum.y=col_date(format = ""), Herstellernummer.y=col_integer(),
                 Werksnummer.y=col_integer(), Fehlerhaft_Datum.y=col_date(format = ""),
                 Fehlerhaft_Fahrleistung.y=col_integer(), ID_Motor=col_character(),
                 Produktionsdatum=col_date(format = ""), Herstellernummer=col_integer(),
                 Werksnummer=col_integer(),Fehlerhaft_Datum=col_date(format = ""),
                 Fehlerhaft_Fahrleistung=col_integer()))
```

Besides, it is necessary to find the location of the vehicles in Germany. Additional data sets have the required information for this. "OpenGeoDB_bundesland_plz_ort_de (1)", "Zulassungen_alle_Fahrzeuge" and "Geodaten_Gemeinden_v1.2_2017-08-22_TrR" are imported by the "readr" package and the "readexcel" package.
"OpenGeoDB_bundesland_plz_ort_de (1)" contains the information about the German state, places and postcode.
"Zulassungen_alle_Fahrzeuge" contains information about the vehicle ID, the location and the date of registration.
"Geodaten_Gemeinden_v1.2_2017-08-22_TrR" contains the location, postal code as well as the longitude and latitude of the location, which is very important for developing the Shiny App. 
An overview is given by the following table:


```{r import location, warning = FALSE, message=FALSE}
# Import Location and Zulassung

data_bundesland_plz_ort <- read_excel("./Data/Zulassungen/OpenGeoDB_bundesland_plz_ort_de (1).xls", col_names = c("Bundesland","PLZ","Ort"))

#Problem mit L채nge der PLZ bei Transformation zu integer (see "Leading Zeros") bei Sachsen
#data_bundesland_plz_ort$PLZ <- as.integer(data_bundesland_plz_ort$PLZ)

data_Zulassung <- read_csv2("./Data/Zulassungen/Zulassungen_alle_Fahrzeuge.csv")

data_Geodaten_Gemeinden <- read_csv2("./Data/Geodaten/Geodaten_Gemeinden_v1.2_2017-08-22_TrR.csv",col_types =                                    cols(Postleitzahl=col_character(),Laengengrad=col_double(),Breitengrad=col_double()))
```
# Data Preparation
## Tidy
In this section, the data sets are tidied up. Here, unnecessary columns are deleted, the format gets updated and additional information is added. 

### Tidy vehicle data sets

```{r tidy vehicle data, warning = FALSE, message= FALSE}
#Delete unnecessary columns in two different data tables
data_bestandteile_oem1_typ11$X1<- NULL # Delete unnecessary column

data_bestandteile_oem1_typ12$X1<- NULL # Delete unnecessary column


# Tidy Komponente K1DI1
# Information was spread over several columns and had to be gathered into single columns
data_komponente_k1di1 <- data_komponente_k1di1 %>%
  select(ID_Motor.x,ID_Motor.y,ID_Motor,Produktionsdatum.x,Produktionsdatum.y,Produktionsdatum)%>% # Select only relevant data columns
  gather('ID_Motor.x','ID_Motor.y','ID_Motor', key = "Motoren",value="ID_Motor_K1DI1", na.rm=TRUE) %>% #Gather all engine IDs into one column
  gather('Produktionsdatum.x','Produktionsdatum.y','Produktionsdatum', key = "Daten",value="Produktionsdatum_K1DI1", na.rm=TRUE)%>% #Gather all production dates of the engines into one column
  select(ID_Motor_K1DI1,Produktionsdatum_K1DI1)%>% #Select only the columns with complete data
  rename(ID_Motor=ID_Motor_K1DI1, Produktionsdatum=Produktionsdatum_K1DI1) #Rename those selected columns
```
### Tidy geographical data sets

Unfortunately, the data set "data_bundesland_plz_ort" is missing the places "Seeg", "Roemhild", "Hoerselberg Hainich" and "Gruenhain Beierfeld", which are added by hand. This missing data was found by the later joining and evaluating the structure of the data set.
The Community Mockrehna in Sachsen had a wrong post code which was then adapted by hand.
Furthermore, place obervations sometimes contain  numbers, which were deleted by the use of the "tm" package.

"Zulassungen_alle_Fahrzeuge" contains the data, where the cars got the admission. There, the location has to be cleaned by eliminating additional numbers. In addition, the letters have been changed from purely upper case to upper and lower case letters.
```{r tidy geographical data, warning = FALSE, message= FALSE}
# Tidy Bundesland Ort,PLZ
data_bundesland_plz_ort <- data_bundesland_plz_ort%>% #import data
  add_row(Bundesland="Bayern",PLZ="87637",Ort="Seeg") %>% # add data to the data set
  add_row(Bundesland="Th체ringen",PLZ="98630",Ort="Roemhild") %>% # add data to the data set
  add_row(Bundesland="Th체ringen",PLZ="99820",Ort="Hoerselberg Hainich") %>% # add data to the data set
  subset(Ort!="Mockrehna")%>% # remove row with false PLZ, Source: https://stackoverflow.com/questions/12328056/how-do-i-delete-rows-in-a-data-frame
  add_row(Bundesland="Sachsen",PLZ="04862",Ort="Mockrehna")%>% # add data to the data set
  add_row(Bundesland="Sachsen",PLZ="08344",Ort="Gruenhain Beierfeld")

data_bundesland_plz_ort$Ort <- removeNumbers(data_bundesland_plz_ort$Ort)# remove unnecessary numbers, for more in  https://stackoverflow.com/questions/13590139/remove-numbers-from-alphanumeric-characters

#Zulassung

data_Zulassung<-data_Zulassung%>%
  rename(Ort=Gemeinden)# Rneame column for consirnecy
data_Zulassung$Ort <- str_to_title(data_Zulassung$Ort) # convert the word with one big capital letter
data_Zulassung$Ort <- removeNumbers(data_Zulassung$Ort) # Remove unnecessary numbers in location
data_Zulassung$X1 <- NULL # Remove unnecessary column

#Geodaten Gemeiden

data_Geodaten_Gemeinden<-data_Geodaten_Gemeinden%>%
  rename(Ort=Gemeinde,PLZ= Postleitzahl)%>%
  add_row(PLZ="87637",Ort="Seeg",Laengengrad=10.6104157,Breitengrad=47.6542215)
  
data_Geodaten_Gemeinden$PLZ <- str_pad(data_Geodaten_Gemeinden$PLZ,5,pad = "0") # Add missing Zeros to PLZ length under 5, for more info see https://stackoverflow.com/questions/5812493/how-to-add-leading-zeros
data_Geodaten_Gemeinden$Ort <- removeNumbers(data_Geodaten_Gemeinden$Ort) # Remove unnecessary numbers in location
data_Geodaten_Gemeinden$Ort <- str_to_title(data_Geodaten_Gemeinden$Ort) # convert the word with one big capital letter
data_Geodaten_Gemeinden <- data_Geodaten_Gemeinden[,c(-1,-2)] # Remove unnecessary column
```
## Transforamtaion
In this section, the principles of data manipulation are used to get a compact data set. Mostly, the "dplyr" package is used.

### Data manipulation

The following data sets have to be manipulated:

* "Bestandteile OEM1 Typ11" (data_bestandteile_oem1_typ11 -> new_data_bestandteile_oem1_typ11): Here, the diesel engine "K1DI1" is filtered out and just the two ID's for the vehicle and the engine (ID_Motor,ID_Fahrzeug) are selected for further analysis

* "Bestandteile OEM1 Typ12" (data_bestandteile_oem1_typ12 -> new_data_bestandteile_oem1_typ12):
  Here the diesel engine "K1DI1" is filtered out and just the two ID's for the vehicle and the engine (ID_Motor,ID_Fahrzeug) are selected for further analysis

* "Komponente" (data_komponente_k1di1  -> new_data_komponente_k1di1 ): Here, the production date is filtered to find the engines that were produced between 1st March 2008 and 11th May 2012.

* "Zulassung" (data_Zulassung -> new_data_Zulassung): First of all, the ID column (IDNummer) is renamed to ID_Fahrzeug, just like the column name in the other data sets. ID_Fahrzeug, Ort, Zulassung are selected. Besides, a colomn, named "ID_Fahrzeug_Nummer" is introduced.

Now, all data sets are ready for joining.
```{r data manipulation, warning = FALSE, message=FALSE}

new_data_bestandteile_oem1_typ11 <- data_bestandteile_oem1_typ11 %>%
  filter(grepl("K1DI1",ID_Motor,fixed=TRUE))%>% # Filter after the relevant motor for more information : https://www.rdocumentation.org/packages/dplyr/versions/0.7.8/topics/filter
  select(ID_Motor,ID_Fahrzeug) #Select relevant coulums
  

new_data_bestandteile_oem1_typ12 <- data_bestandteile_oem1_typ12 %>%
  filter(grepl("K1DI1",ID_Motor,fixed=TRUE))%>% # Filter for relevant motor 
  select(ID_Motor,ID_Fahrzeug)# select necessary columns

# Filter Engine K1DI1 for specified production dates
new_data_komponente_k1di1 <- data_komponente_k1di1 %>%
  filter(between(Produktionsdatum, as.Date("2008-03-01"), #Filter for relevant timeperiod
                                  as.Date("2012-05-11")))# Filter after the relevant time period for more information: https://stackoverflow.com/questions/28335715/r-how-to-filter-subset-a-sequence-of-dates

# Transform data_Zulassung
new_data_Zulassung <- data_Zulassung %>%
  rename(ID_Fahrzeug=IDNummer)%>% # Rename column for consistency
  select(ID_Fahrzeug,Ort,Zulassung) # Select relevant columns

```
### Joining
In this step, the final data set is created. This process is divided up into different steps: Joining all vehicle data, joining all geographical data and then joining these two data sets together. 

#### Joining vehicle data:

* The data sets Bestandteile OEM1 Typ 11/12 are put together.
* Then the Komponente data set is leftjoined with Bestandteile OEM1 by the vehicle ID

The result is that the data set "data_vehicle" contains all relevant vehicle information.

```{r joining vehicle data, warning = FALSE, message= FALSE}
#Summarise datatset bestandteile from oem1 Typ 11/12
data_bestandteile_OEM1 <- bind_rows(new_data_bestandteile_oem1_typ11, 
                                    new_data_bestandteile_oem1_typ12) # Get one date set from Type 11 and type 12


#Joining Komponente K1DI1 and Bestandteile OEM
data_vehicle <- left_join(new_data_komponente_k1di1, data_bestandteile_OEM1, by="ID_Motor")%>%
  drop_na()%>%
  distinct()

# Graphical illustration:
graph_data_vehicle <- data_vehicle%>%
  head(5)
kable(graph_data_vehicle, caption = "Summary: Vehicle Data")
```

#### Joining geographical data:

* The Data sets "Gemeinden" and "Bundesland" are leftjoined by the postal code. As some German states share postcal codes, some cities/communities are assigned a wrong state. For instance, this is the case for Oststeinbek and Stapelfeld which are both located in Schleswig-Holstein but are assigned the state Hamburg, as they are right next to the city.
* To the resulting data set, another column is added, which shows the distance between Hamburg and any location in the data set.
* The result is a bundled data set containing locations, longitude, latitude and the postal code. Next, the data set is merged
* Finally, the result is leftjoined by postal code with Zulassung. Now, every vehicle has a location.
```{r joining geographical data, warning = FALSE, message=FALSE}


# One data set for location
data_Ort2 <- left_join(data_Geodaten_Gemeinden,data_bundesland_plz_ort, by="PLZ")%>%
  rename(Ort=Ort.x)%>%
  distinct(Ort, .keep_all=TRUE)
data_Ort2$Ort.y <- NULL # delete extra column after joining

#Calculate distance from Hamburg for every City
dist<-c()# Create an empty vetcot
data_Ort2_matrix <- data_Ort2 %>% # Asign joined data data_Ort2
  select(Laengengrad, Breitengrad)%>% # Choose relevant columns for calculations
  data.matrix() # Covert to matrix for later calculations
for (i in 1:nrow(data_Ort2)){
   calc <- round(as.integer(distm(c(data_Ort2_matrix[i,1],data_Ort2_matrix[i,2]),c(9.993682,53.551085),fun=distGeo)),
                 digits=0) # Calculate the distance between a location and Hamburg city center by the distm function. For more inforamtion visit: https://cran.r-project.org/web/packages/geosphere/geosphere.pdf
   dist[i]<-calc # Store the result in a vector  
}


#Cbinding distance calculation to the data_Ort2 Dataframe 
data_Ort2<-cbind(data_Ort2,dist)

#Joining geographical data
data_Ort <- left_join(new_data_Zulassung,data_Ort2, by="Ort")

#Graphical illustration
graph_data_ort <- data_Ort%>%
  head(5)

kable(graph_data_ort,caption="Summary: Geographical Data ")
```
# Creation of final detaset

To create the final data set, the *vehicle data* set is joined with the *geographical data*. Also, a new column is added to the data set which displays the total number of affected cars in a city/community.
The last step is to save the final data set.


```{r final data, warning = FALSE, message=FALSE}
# Final Dataset
final_data_Group_50 <- left_join(data_vehicle,data_Ort,by="ID_Fahrzeug")
                                 
number_towns <- final_data_Group_50%>%  
  count(Ort)
final_data_Group_50 <- left_join(final_data_Group_50,number_towns,by="Ort")%>%
  distinct(ID_Fahrzeug, .keep_all=TRUE)

save(final_data_Group_50, file="final_data_Group_50.Rda")


# delete duplicate rows
#final_data_Group_50 <- distinct(final_data_Group_50)
```


# Evaluation

## Designing the Shiny-App

After the data was prepared and merged into a final data set, we developed a Shiny-App to evaluate the data.
The content aspects that needed to be implemented were:

Develop a Shiny app and visualize the following:

*	A variable user input that defines the number and radii of concentric perimeters

*	A bar graph that displays the number of registered vehicles that were registered within that area of each perimeter. The larger area always contains the data of the smaller areas.

*	A map of Germany visualizing the defined perimeters around Hamburg. For each commune with registered cars that are affected, create a pop-up to display the number of affected cars.

*	Highlight cities and communities on the map which have a certain amount (user input in relative or absolute numbers) or more effected registered vehicles.

*	Your basic dataset so you can prove your visualization. Remember: Only show necessary attributes. Therefore, add a table to your application, containing only necessary content.

## Implementing the App

First, we loaded the shiny package and with install.load, we installed all further required R packages. Afterwards, we loaded the data set final_data_Group_50 which we had prepared in the steps before.


### User Interface (UI)
Then, we had to program the UI. As required, we changed the font and also the color of the App title.
To adjust the layout to the color "grass-green" we had to find out which color or color code was meant by this color name as there were several options. We decided to use the code **#698b47** after https://www.britishstandardcolour.com/ or https://www.w3schools.com/colors/colors_british.asp .

While designing the UI, we colored the title of the App as well as the input sliders in the color "Grass Green". We chose the shinytheme "sandstone" as the App theme because it harmonizes well with the corporate color.

The Layout is divided into a sidebarPanel and a mainPanel.

The **sidebarPanel** contains adjustable inputs.

Since the user is supposed to be able to choose a number of radii, we used a selectInput. Here, the user can choose between 1 to 6 radii.
Depending on the number of radii chosen, there has to be a variable number of inputSliders to choose the radius for each perimeter. Therefore, we added conditionalPanels depending on the given selectInput.
We also added a sliderInput so that the user can assign a critical amount of affected vehicles.


In the **mainPanel**, the outputs are displayed and it contains a logo, as demanded.

The mainPanel contains four tabPanels, i.e. a map, a barplot, a table, and the basic dataset to prove all visualisations.



### Server

In the server, various reactive functions are defined and data tables are manipulated to to be able to generate the requested visualizations.

#### The Map

The **map** ist divided into the two groups *Clustered Markers* and *Cities of Interest*.

In the Clustered Markers group, the concentric perimeters around Hamburg are visualised. Cities and communities are clustered and the number of affected cars is being displayed.

In the Cities of interest group, cities/communities are highlighted with a red marker if the critical number of affected vehicles specified by the user is reached or exceeded.

![The Map](https://64.media.tumblr.com/10ae244a6f9a5f9a2c69524659e14354/df57ad3bf189a1a8-15/s2048x3072/d79336f13ef58e6c115fbc78dceb723035a2f17b.png)

[comment]: <> (![Clustered Markers]( URL HIER))

[comment]: <> (![Cities of Interest, critical amount = 300 cars]( URL HIER))



